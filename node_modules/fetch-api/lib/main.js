'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
//     node-react-native-fetch-api
//     Copyright (c) 2015- Nick Baugh <niftylettuce@gmail.com>
//     MIT Licensed

// * Author: [@niftylettuce](https://twitter.com/#!/niftylettuce)
// * Source: <https://github.com/niftylettuce/node-react-native-fetch-api>

// # node-react-native-fetch-api

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _debug2.default)('fetch-api');
var fetch = typeof window === 'undefined' ? global.fetch : window.fetch;

if (!fetch) throw new Error('fetch is required, use `whatwg-fetch` or `node-fetch`');

var methods = ['get', 'head', 'post', 'put', 'del', 'options', 'patch'];

var Api = (function () {
  function Api(opts) {
    var _this = this;

    _classCallCheck(this, Api);

    this.opts = opts || {};

    if (!this.opts.baseURI) throw new Error('baseURI option is required');

    this.headers = _extends({}, opts.headers, {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    });

    // support `auth` being an array or a string
    // and if it is a string and contains ':'
    // then split on that and only return 2 keys
    if (this.opts.auth) this.auth(this.opts.auth);

    methods.forEach(function (method) {
      _this[method] = _this._setup(method);
    });
  }

  _createClass(Api, [{
    key: '_setup',
    value: function _setup(method) {

      var that = this;

      return function (path, options, callback) {

        // TODO: path must be string

        if (typeof options === 'function') {
          callback = options;
          options = {};
        }

        // TODO: callback must be a function

        var opts = _extends({
          headers: _extends({}, that.headers)
        }, options, {
          method: method === 'del' ? 'DELETE' : method.toUpperCase()
        });

        var res = undefined;

        fetch(that.opts.baseURI + path, opts).then(function (_res) {
          res = _res;
          try {
            _res = _res.json();
          } catch (e) {
            _res = _res.text();
          } finally {
            return _res;
          }
        }).then(function (body) {
          callback(null, res, body);
        }).catch(function (err) {
          callback(err);
        });
      };
    }
  }, {
    key: 'auth',
    value: function auth(creds) {

      if (typeof creds === 'string') {
        var index = creds.indexOf(':');
        if (index !== -1) {
          var split = creds.split(':');
          creds = [split.slice(0), split.slice(index, split.length)];
        } else {
          creds = [creds];
        }
      }

      if (!creds instanceof Array) throw new Error('auth must be an array or string');

      switch (creds.length) {
        case 0:
          creds = new Array('', '');
          break;
        case 1:
          creds.push('');
          break;
        case 2:
          break;
        default:
          throw new Error('auth option can only have two keys `[user, pass]`');
      }

      if (typeof creds[0] !== 'string') throw new Error('auth option `user` must be a string');

      if (typeof creds[1] !== 'string') throw new Error('auth option `pass` must be a string');

      if (creds[0] === '' && creds[1] === '') delete this.headers.Authorization;else this.headers.Authorization = 'Basic ' + new Buffer(creds.join(':')).toString('base64');
    }

    /*
        get(path, fn) {
          fetch(that.opts.baseURI + path, {
            method: 'GET',
            headers: that.headers
          })
          .then((res) => {
            try {
              let response = JSON.parse(res);
              if (response && response.error)
                throw new Error(response.error);
              return res.json();
            } catch (e) {
              return res.text();
            }
          })
          .then((res) => {
            fn(null, res);
          })
          .catch((err) => {
            fn(err);
          })
        },
        post(path, data, fn) {
          if (!fn)
            fn = data;
          fetch(that.opts.baseURI + path, {
            method: 'POST',
            body: JSON.stringify(data),
            headers: that.headers
          })
          .then((res) => res.json())
          .then((res) => {
            if (res && res.error)
              return fn(res.error);
            fn(null, res);
          })
          .catch(fn)
        },
        put(path, data, fn) {
          fetch(that.opts.baseURI + path, {
            method: 'PUT',
            body: JSON.stringify(data),
            headers: that.headers
          })
          .then((res) => res.json())
          .then((res) => {
            if (res && res.error)
              return fn(res.error);
            fn(null, res);
          })
          .catch(fn)
        },
        delete(path, data, fn) {
          fetch(that.opts.baseURI + path, {
            method: 'DELETE',
            headers: that.headers
          })
          .then((res) => res.json())
          .then((res) => {
            if (res && res.error)
              return fn(res.error);
            fn(null, res);
          })
          .catch(fn)
        }
      };
    }
    */

  }]);

  return Api;
})();

exports.default = Api;